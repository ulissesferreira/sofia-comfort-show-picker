<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sofia's Next Comfort Show</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        html {
            width: 100vw;
            height: 100dvh;
            overflow: hidden; /* This will hide both horizontal and vertical overflow */
        }
        /* Custom styles to apply the fonts */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #FFF0F5; /* Lavender Blush - a very light pink */
        }
        .font-dancing-script {
            font-family: 'Dancing Script', cursive;
        }
        /* Animation for the show card */
        .show-card-enter {
            opacity: 0;
            transform: scale(0.9) translateY(20px);
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
        }
        .show-card-enter-active {
            opacity: 1;
            transform: scale(1) translateY(0);
        }
        /* Subtle background gradient */
        .gradient-background {
            background: linear-gradient(135deg, #FFF0F5 0%, #E6E6FA 100%); /* Lavender Blush to Lavender */
        }
        /* Button styling */
        .custom-button {
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .custom-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }
        .custom-button:active {
            transform: translateY(0px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        /* Heart pulse animation */
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .heart-pulse {
            animation: pulse 1.5s infinite;
            display: inline-block;
        }

        #cardStackContainer {
            position: relative;
            height: 80%; /* Occupy 80% of parent <main> height */
            aspect-ratio: 5 / 8; /* Maintain 300/480 ratio */
            max-width: 90vw; /* Prevent excessive width on large screens */
            max-height: 80vh; /* Sensible upper limit for card height */
            /* margin-bottom: 2rem; */ /* Removed as main section now centers it */
        }

        .show-card-instance {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            padding: 1.5rem; /* p-6 */
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); /* shadow-2xl */
            transition: transform 0.5s ease-out, opacity 0.5s ease-out;
            overflow: hidden; /* Ensure content fits card */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* Individual card stacking styles */
        /* #card-0 { z-index: 3; } */ /* Topmost */
        /* #card-1 { z-index: 2; transform: scale(0.95) translateY(15px); } */
        /* #card-2 { z-index: 1; transform: scale(0.90) translateY(30px); } */
        /* Dynamically applied classes for states */
        .card-top {
            transform: scale(1) translateY(0px);
            opacity: 1; /* Explicitly keep top card opaque */
            z-index: 5; /* Adjusted for 5 cards */
        }
        .card-middle {
            transform: scale(0.95) translateY(15px);
            z-index: 4; /* Adjusted */
        }
        .card-back {
            transform: scale(0.90) translateY(30px);
            z-index: 3; /* Adjusted */
        }
        .card-back-deeper-1 {
            transform: scale(0.85) translateY(45px);
            z-index: 2;
        }
        .card-back-deeper-2 {
            transform: scale(0.80) translateY(60px);
            z-index: 1;
        }


        .card-image-container { /* Class for the div holding both images */
            position: relative;
            width: 100%; /* Full width of card padding area */
            height: calc(100% - 171px); /* Adjusted to reserve space for title and 3 lines of desc */
            border-radius: 0.5rem; /* rounded-lg */
            overflow: hidden;
            margin-bottom: 1rem; /* mb-4 */
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06); /* shadow-md */
            margin-left: auto;
            margin-right: auto;
        }
        
        .card-image-bg, .card-image-fg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .card-image-bg { object-fit: cover; filter: blur(8px); /* blur-md */}
        .card-image-fg { object-fit: contain; z-index: 10; }


        .card-title { /* Applied to h2 */
            font-size: 1.875rem; /* text-3xl */
            font-family: 'Dancing Script', cursive;
            color: #7e22ce; /* purple-600 */
            margin-bottom: 0.5rem; /* mb-2 */
            text-align: justify; /* Changed from center */
            line-height: 1.2; /* Adjust for better fit */
            max-height: 2.4em; /* Limit title lines if too long */
            overflow: hidden; /* Hide overflow */
            text-overflow: ellipsis; /* Add ellipsis for long titles */
        }
        .card-description { /* Applied to p */
            font-size: 0.875rem; /* text-sm */
            color: #4b5563; /* text-gray-600 */
            text-align: justify; /* Changed from center */
            overflow: hidden; /* Needed for line-clamp */
            text-overflow: ellipsis; /* Fallback */
            display: -webkit-box;
            -webkit-box-orient: vertical;
            -webkit-line-clamp: 3; /* Limit to 3 lines and show ellipsis */
            line-height: 1.4; /* Added for predictable line height */
            padding-bottom: 1rem; /* User requested padding */
        }

    </style>
</head>
<body class="gradient-background h-full flex flex-col items-center p-4 text-gray-700">

    <div class="container mx-auto max-w-lg text-center flex flex-col h-full w-full">

        <header class="flex-none basis-[15%] flex flex-col justify-center items-center mb-0 relative z-0">
            <h1 class="font-dancing-script text-5xl md:text-7xl text-pink-500 drop-shadow-md">
                Comfort Show
            </h1>
        </header>

        <main class="flex-grow basis-[70%] w-full flex flex-col items-center justify-center relative z-10">
            <div id="cardStackContainer">
                <!-- Cards will be dynamically managed but let's put placeholders for structure -->
                <div id="card-0" class="show-card-instance cursor-grab">
                    <div class="card-image-container">
                        <img data-role="image-bg" src="https://placehold.co/300x450/cccccc/333333?text=Loading..." alt="" class="card-image-bg" aria-hidden="true">
                        <img data-role="image-fg" src="https://placehold.co/300x450/cccccc/333333?text=Loading..." alt="Show Poster" class="card-image-fg" onerror="handleImageError(this.parentElement.querySelector('[data-role=image-fg]'), this.parentElement.querySelector('[data-role=image-bg]'))">
                    </div>
                    <h2 data-role="title" class="card-title">Loading Show...</h2>
                    <p data-role="description" class="card-description">Please wait a moment.</p>
                </div>
                <div id="card-1" class="show-card-instance">
                     <div class="card-image-container">
                        <img data-role="image-bg" src="https://placehold.co/300x450/cccccc/333333?text=Next" alt="" class="card-image-bg" aria-hidden="true">
                        <img data-role="image-fg" src="https://placehold.co/300x450/cccccc/333333?text=Next" alt="Show Poster" class="card-image-fg" onerror="handleImageError(this.parentElement.querySelector('[data-role=image-fg]'), this.parentElement.querySelector('[data-role=image-bg]'))">
                    </div>
                    <h2 data-role="title" class="card-title"></h2>
                    <p data-role="description" class="card-description"></p>
                </div>
                <div id="card-2" class="show-card-instance">
                    <div class="card-image-container">
                        <img data-role="image-bg" src="https://placehold.co/300x450/cccccc/333333?text=Later" alt="" class="card-image-bg" aria-hidden="true">
                        <img data-role="image-fg" src="https://placehold.co/300x450/cccccc/333333?text=Later" alt="Show Poster" class="card-image-fg" onerror="handleImageError(this.parentElement.querySelector('[data-role=image-fg]'), this.parentElement.querySelector('[data-role=image-bg]'))">
                    </div>
                    <h2 data-role="title" class="card-title"></h2>
                    <p data-role="description" class="card-description"></p>
                </div>
                <div id="card-3" class="show-card-instance">
                    <div class="card-image-container">
                        <img data-role="image-bg" src="https://placehold.co/300x450/cccccc/333333?text=Hidden" alt="" class="card-image-bg" aria-hidden="true">
                        <img data-role="image-fg" src="https://placehold.co/300x450/cccccc/333333?text=Hidden" alt="Show Poster" class="card-image-fg" onerror="handleImageError(this.parentElement.querySelector('[data-role=image-fg]'), this.parentElement.querySelector('[data-role=image-bg]'))">
                    </div>
                    <h2 data-role="title" class="card-title"></h2>
                    <p data-role="description" class="card-description"></p>
                </div>
                <div id="card-4" class="show-card-instance">
                    <div class="card-image-container">
                        <img data-role="image-bg" src="https://placehold.co/300x450/cccccc/333333?text=Hidden" alt="" class="card-image-bg" aria-hidden="true">
                        <img data-role="image-fg" src="https://placehold.co/300x450/cccccc/333333?text=Hidden" alt="Show Poster" class="card-image-fg" onerror="handleImageError(this.parentElement.querySelector('[data-role=image-fg]'), this.parentElement.querySelector('[data-role=image-bg]'))">
                    </div>
                    <h2 data-role="title" class="card-title"></h2>
                    <p data-role="description" class="card-description"></p>
                </div>
            </div>

            <div id="endOfDeckUI" class="text-center mt-8" style="display: none;">
                <p id="endOfDeckMessage" class="text-xl text-pink-500 mb-4">You've seen all the shows!</p>
                <button id="reshuffleButton"
                        class="custom-button bg-purple-500 hover:bg-purple-600 text-white font-semibold py-3 px-8 rounded-full text-lg shadow-lg focus:outline-none focus:ring-2 focus:ring-purple-300 focus:ring-opacity-50">
                    💖 Shuffle Again! 💖
                </button>
            </div>

        </main>

        <footer class="flex-none basis-[15%] w-full flex flex-col items-center justify-around text-center relative z-0">
            <button id="findShowButton"
                    class="custom-button bg-pink-400 hover:bg-pink-500 text-white font-semibold py-3 px-8 rounded-full text-lg shadow-lg focus:outline-none focus:ring-2 focus:ring-pink-300 focus:ring-opacity-50">
                ✨ Next Show! ✨
            </button>
            <p class="text-sm text-pink-400">Love you <span class="heart-pulse">💖</span></p>
        </footer>

    </div>

    <script>
        const shows = [
            {
                title: "New Girl",
                imdbID: "tt1826940",
                img: "https://placehold.co/300x450/fbcfe8/86198f?text=New+Girl" // Fallback image
            },
            {
                title: "Modern Family",
                imdbID: "tt1442437",
                img: "https://placehold.co/300x450/cffafe/0e7490?text=Modern+Family",
            },
            {
                title: "Grey's Anatomy",
                imdbID: "tt0413573",
                img: "https://placehold.co/300x450/fef9c3/854d0e?text=Grey%27s+Anatomy",
            },
            {
                title: "How I Met Your Mother",
                imdbID: "tt0460649",
                img: "https://placehold.co/300x450/dcfce7/15803d?text=How+I+Met+Your+Mother",
            },
            {
                title: "How I Met Your Father",
                imdbID: "tt14500082",
                img: "https://placehold.co/300x450/e9d5ff/581c87?text=How+I+Met+Your+Father",
            },
            {
                title: "Sex and the City",
                imdbID: "tt0159206",
                img: "https://placehold.co/300x450/ffd1dc/9d174d?text=Sex+and+the+City",
            },
            {
                title: "And Just Like That...",
                imdbID: "tt13819960",
                img: "https://placehold.co/300x450/bae6fd/075985?text=Sex+and+the+City+(New)",
            },
            {
                title: "Sex Lives of College Girls",
                imdbID: "tt11212276",
                img: "https://placehold.co/300x450/fed7aa/c2410c?text=Sex+Lives+of+College+Girls",
            },
            {
                title: "Big Bang Theory",
                imdbID: "tt0898266",
                img: "https://placehold.co/300x450/fbcfe8/86198f?text=Big+Bang+Theory",
            },
            {
                title: "The Middle",
                imdbID: "tt1442464",
                img: "https://placehold.co/300x450/cffafe/0e7490?text=The+Middle",
            },
            {
                title: "Rookie",
                imdbID: "tt7587890", // The Rookie
                img: "https://placehold.co/300x450/fef9c3/854d0e?text=Rookie",
            },
            {
                title: "Castle",
                imdbID: "tt1219024",
                img: "https://placehold.co/300x450/dcfce7/15803d?text=Castle",
            },
            {
                title: "Gilmore Girls",
                imdbID: "tt0238784",
                img: "https://placehold.co/300x450/e9d5ff/581c87?text=Gilmore+Girls",
            },
            {
                title: "Schitts Creek",
                imdbID: "tt3526078",
                img: "https://placehold.co/300x450/ffd1dc/9d174d?text=Schitts+Creek",
            },
            {
                title: "Friends",
                imdbID: "tt0108778",
                img: "https://placehold.co/300x450/bae6fd/075985?text=Friends",
            },
            {
                title: "Brooklyn Nine Nine",
                imdbID: "tt2467372",
                img: "https://placehold.co/300x450/fed7aa/c2410c?text=Brooklyn+Nine+Nine",
            },
            {
                title: "The Good Place",
                imdbID: "tt4955642",
                img: "https://placehold.co/300x450/fbcfe8/86198f?text=The+Good+Place",
            },
            {
                title: "Grace and Frankie",
                imdbID: "tt3609352",
                img: "https://placehold.co/300x450/cffafe/0e7490?text=Grace+and+Frankie",
            },
            {
                title: "Jane the Virgin",
                imdbID: "tt3566726",
                img: "https://placehold.co/300x450/fef9c3/854d0e?text=Jane+the+Virgin",
            },
            {
                title: "That 70s Show",
                imdbID: "tt0165598",
                img: "https://placehold.co/300x450/dcfce7/15803d?text=That+70s+Show",
            },
            {
                title: "That 90s Show",
                imdbID: "tt15591076",
                img: "https://placehold.co/300x450/e9d5ff/581c87?text=That+90s+Show",
            },
            {
                title: "Young Sheldon",
                imdbID: "tt6226232",
                img: "https://placehold.co/300x450/ffd1dc/9d174d?text=Young+Sheldon",
            },
            {
                title: "Bridgerton",
                imdbID: "tt8740790",
                img: "https://placehold.co/300x450/bae6fd/075985?text=Bridgerton",
            }
        ];

        // DOM Elements
        const findShowButton = document.getElementById('findShowButton');
        const cardStackContainer = document.getElementById('cardStackContainer'); // Renamed
        const cardElements = [ // Array of the 3 card divs
            document.getElementById('card-0'),
            document.getElementById('card-1'),
            document.getElementById('card-2'),
            document.getElementById('card-3'),
            document.getElementById('card-4')
        ];
        const endOfDeckUI = document.getElementById('endOfDeckUI');
        const reshuffleButton = document.getElementById('reshuffleButton');

        let shuffledShows = [];
        let currentCardIndex = 0; // Start at 0 for the first card in the deck
        const OMDbAPIKey = "88908dd6";

        let isSwiping = false;
        let swipeStartX = 0;
        let swipeStartY = 0;
        let swipeTranslateX = 0;
        let swipeTranslateY = 0;
        let swipeStartTime = 0;
        const MIN_SWIPE_VELOCITY = 0.5; // pixels per millisecond
        const SWIPE_DISMISS_THRESHOLD = 75; // Min distance for a swipe to be considered for dismissal
        const TRANSPARENT_PIXEL = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';

        function createCardHTMLString() {
            // Using a generic placeholder ID like 'new-card-placeholder' initially.
            // The proper ID (card-0 to card-4) will be assigned in dismissAndCycleCards.
            return `
                <div class="show-card-instance">
                    <div class="card-image-container">
                        <img data-role="image-bg" src="https://placehold.co/300x450/cccccc/333333?text=Hidden" alt="" class="card-image-bg" aria-hidden="true">
                        <img data-role="image-fg" src="https://placehold.co/300x450/cccccc/333333?text=Hidden" alt="Show Poster" class="card-image-fg" onerror="handleImageError(this.parentElement.querySelector('[data-role=image-fg]'), this.parentElement.querySelector('[data-role=image-bg]'))">
                    </div>
                    <h2 data-role="title" class="card-title"></h2>
                    <p data-role="description" class="card-description"></p>
                </div>
            `;
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        async function updateCardElement(cardEl, showData) {
            if (!cardEl) return;

            const titleEl = cardEl.querySelector('[data-role="title"]');
            const descriptionEl = cardEl.querySelector('[data-role="description"]');
            const imgFgEl = cardEl.querySelector('[data-role="image-fg"]');
            const imgBgEl = cardEl.querySelector('[data-role="image-bg"]');
            const cardImageContainer = cardEl.querySelector('.card-image-container');

            if (showData) {
                cardEl.style.backgroundColor = 'white'; // Ensure default background
                if (cardImageContainer) cardImageContainer.style.visibility = 'visible';
                if (titleEl) titleEl.style.visibility = 'visible';
                if (descriptionEl) descriptionEl.style.visibility = 'visible';

                if (titleEl) titleEl.textContent = showData.title;
                if (imgFgEl) imgFgEl.alt = showData.title + " Poster";

                let imageUrlToLoad = showData.img; // Fallback image from array
                let plotDescription = "Plot not available."; // Default description

                if (showData.imdbID) {
                    try {
                        const response = await fetch(`https://www.omdbapi.com/?i=${showData.imdbID}&apikey=${OMDbAPIKey}`);
                        const data = await response.json();
                        if (data.Poster && data.Poster !== "N/A") {
                            imageUrlToLoad = data.Poster;
                        } else {
                            console.warn(`No OMDb poster for ${showData.title}. Using fallback from shows array.`);
                        }
                        if (data.Plot && data.Plot !== "N/A") {
                            plotDescription = data.Plot;
                        } else {
                            console.warn(`No OMDb plot for ${showData.title}.`);
                        }
                    } catch (error) {
                        console.error("Error fetching from OMDb API for " + showData.title + ":", error);
                        // imageUrlToLoad remains showData.img (initial fallback)
                        // plotDescription remains "Plot not available."
                    }
                }
                if (imgFgEl) imgFgEl.src = imageUrlToLoad;
                if (imgBgEl) imgBgEl.src = imageUrlToLoad;
                if (descriptionEl) descriptionEl.textContent = plotDescription; // Set the plot as description
            } else {
                // Style as a placeholder card for shadow consistency
                // Content is made invisible, but card structure remains and casts shadow.
                if (titleEl) titleEl.textContent = '';
                if (descriptionEl) descriptionEl.textContent = '';
                
                if (imgFgEl) {
                    imgFgEl.src = TRANSPARENT_PIXEL;
                    imgFgEl.alt = "";
                }
                if (imgBgEl) {
                    imgBgEl.src = TRANSPARENT_PIXEL;
                }

                if (cardImageContainer) cardImageContainer.style.visibility = 'hidden';
                if (titleEl) titleEl.style.visibility = 'hidden';
                if (descriptionEl) descriptionEl.style.visibility = 'hidden';
                
                cardEl.style.backgroundColor = 'white'; // Ensure it's a white card
                cardEl.style.display = ''; // Ensure card element itself is displayed
            }
        }

        async function displayStackedCards(isInitialDeckLoad = false) {
            const activeCardElement = cardElements[0]; // Current top card DOM element
            
            // Reset active card's visual state IF it's not currently being dismissed
            // This is more for the initial load or a reset.
            if (activeCardElement.style.opacity !== '0') { // Check if it's not already mid-dismissal
                activeCardElement.style.transition = 'none';
                activeCardElement.style.transform = 'translateX(0px) translateY(0px) rotate(0deg)';
                activeCardElement.style.opacity = '1';
                void activeCardElement.offsetWidth; // Reflow
            }

            if (currentCardIndex >= 0 && currentCardIndex < shuffledShows.length) {
                cardStackContainer.style.display = '';
                endOfDeckUI.style.display = 'none';
                findShowButton.disabled = false;
                
                // Load data for all 5 card elements
                await updateCardElement(cardElements[0], shuffledShows[currentCardIndex]);
                await updateCardElement(cardElements[1], shuffledShows[currentCardIndex + 1]);
                await updateCardElement(cardElements[2], shuffledShows[currentCardIndex + 2]);
                await updateCardElement(cardElements[3], shuffledShows[currentCardIndex + 3]);
                await updateCardElement(cardElements[4], shuffledShows[currentCardIndex + 4]);

                // Apply visual stacking styles using classes
                const restingClasses = ['card-top', 'card-middle', 'card-back', 'card-back-deeper-1', 'card-back-deeper-2'];
                const remainingShows = shuffledShows.length - currentCardIndex;

                cardElements.forEach((el, domCardIndex) => {
                    el.classList.remove('card-top', 'card-middle', 'card-back', 'card-back-deeper-1', 'card-back-deeper-2', 'cursor-grab');
                    el.style.transition = 'transform 0.5s ease-out, opacity 0.5s ease-out'; // Default transition

                    if (domCardIndex < remainingShows) {
                        el.style.display = '';
                        if (domCardIndex < restingClasses.length) {
                            el.classList.add(restingClasses[domCardIndex]);
                        }
                        if (domCardIndex === 0) {
                            el.classList.add('cursor-grab');
                            // Listeners are setup once in startNewDeck or after dismissal
                        }
                    } else {
                        updateCardElement(el, null); // Clear content for hidden cards
                        el.style.display = 'none';
                    }
                });

                // Entrance animation for the very first card of a new deck
                if (isInitialDeckLoad && cardElements[0]) {
                     cardElements[0].classList.remove('show-card-enter-active'); // Ensure clean state
                     cardElements[0].classList.add('show-card-enter');
                     requestAnimationFrame(() => {
                         cardElements[0].classList.add('show-card-enter-active');
                     });
                } else if (cardElements[0]){
                    // Ensure non-initial top cards don't re-run enter animation unless explicitly set
                     cardElements[0].classList.remove('show-card-enter', 'show-card-enter-active');
                }

            } else {
                // End of deck
                cardStackContainer.style.display = 'none';
                endOfDeckUI.style.display = '';
                findShowButton.disabled = true;
            }
        }

        function startNewDeck() {
            shuffledShows = [...shows];
            shuffleArray(shuffledShows);
            currentCardIndex = 0;
            swipeTranslateX = 0;
            swipeTranslateY = 0;

            // Reset IDs and classes to initial state for the card elements before display
            cardElements.forEach((el, i) => {
                el.id = `card-${i}`; // Reset IDs: card-0, card-1, card-2, card-3, card-4
                el.classList.remove('card-top', 'card-middle', 'card-back', 'card-back-deeper-1', 'card-back-deeper-2', 'show-card-enter', 'show-card-enter-active');
                el.style.transform = ''; // Clear any inline transforms
                el.style.opacity = ''; // Clear any inline opacity
                el.style.zIndex = ''; // Clear any inline zIndex
            });
            
            displayStackedCards(true); // Pass true for initial deck load
            findShowButton.disabled = (shuffledShows.length === 0);
        }
        
        function dismissAndCycleCards(cardToDismiss, finalDeltaX, finalDeltaY) {
            if (!cardToDismiss || currentCardIndex < 0 || currentCardIndex >= shuffledShows.length) return;

            cardToDismiss.style.zIndex = '6'; // Ensure dismissing card is on top during its animation

            // 1. Start Dismiss Animation for the top card
            const projectionFactor = 3; 
            const targetTx = finalDeltaX * projectionFactor;
            const targetTy = finalDeltaY * projectionFactor;
            const rotation = (finalDeltaX / cardToDismiss.offsetWidth) * 25;

            cardToDismiss.style.transition = 'transform 0.4s ease-out, opacity 0.4s ease-out';
            cardToDismiss.style.transform = `translateX(${targetTx}px) translateY(${targetTy}px) rotate(${rotation}deg)`;
            cardToDismiss.style.opacity = '0';
            cardToDismiss.classList.remove('cursor-grabbing', 'cursor-grab');

            // 2. Simultaneous Animation for the rest of the stack shifting up
            const stackAnimationClasses = ['card-top', 'card-middle', 'card-back', 'card-back-deeper-1']; // Target classes
            for (let i = 1; i < cardElements.length; i++) {
                const cardEl = cardElements[i];
                if (cardEl) {
                    cardEl.style.transition = 'transform 0.4s ease-out'; // Only animate transform
                    // Remove all current stacking classes before adding the target one
                    cardEl.classList.remove('card-top', 'card-middle', 'card-back', 'card-back-deeper-1', 'card-back-deeper-2');
                    if (i - 1 < stackAnimationClasses.length) {
                        cardEl.classList.add(stackAnimationClasses[i-1]);
                    }
                }
            }
            
            // 3. After ALL animations complete (dismissal + stack shift)
            setTimeout(() => {
                currentCardIndex++;

                const dismissedElement = cardElements.shift(); // Remove from front of array
                dismissedElement.remove(); // DELETE THE DOM ELEMENT

                // Create and add a new card element to the DOM and array
                const newCardHTML = createCardHTMLString();
                cardStackContainer.insertAdjacentHTML('beforeend', newCardHTML);
                const newCardElement = cardStackContainer.lastElementChild;
                cardElements.push(newCardElement); // Add new element to end of array

                // Reset styles and update content for all cards in their new order
                const restingClasses = ['card-top', 'card-middle', 'card-back', 'card-back-deeper-1', 'card-back-deeper-2'];
                const remainingShowsAfterDismiss = shuffledShows.length - currentCardIndex;

                cardElements.forEach((el, domCardIndex) => {
                    el.style.transition = 'none'; // Temporarily disable transitions
                    el.id = `card-${domCardIndex}`;
                    el.style.opacity = '1'; // Ensure all cards are opaque (those that remain visible)
                    el.style.zIndex = ''; // Clear any inline zIndex
                    el.classList.remove('card-top', 'card-middle', 'card-back', 'card-back-deeper-1', 'card-back-deeper-2', 'cursor-grab', 'show-card-enter', 'show-card-enter-active');

                    if (domCardIndex < remainingShowsAfterDismiss) {
                        el.style.display = '';
                        updateCardElement(el, shuffledShows[currentCardIndex + domCardIndex]);
                        if (domCardIndex < restingClasses.length) {
                            el.classList.add(restingClasses[domCardIndex]);
                        }
                        if (domCardIndex === 0) {
                            el.classList.add('cursor-grab');
                            setupSwipeListeners(el);
                        }
                    } else {
                        updateCardElement(el, null); // Clear content, make placeholder
                        el.style.display = 'none'; // Hide if not part of remaining stack
                    }
                });
                
                void cardStackContainer.offsetWidth; // Force reflow before re-enabling transitions

                // Re-enable standard transitions for future interactions ONLY for visible cards
                cardElements.forEach((el, domCardIndex) => {
                    if (domCardIndex < remainingShowsAfterDismiss) {
                        el.style.transition = 'transform 0.5s ease-out, opacity 0.5s ease-out';
                    } else {
                        el.style.transition = 'none'; // Ensure hidden cards don't animate if made visible later by mistake
                    }
                });

                if (currentCardIndex >= shuffledShows.length) {
                    cardStackContainer.style.display = 'none';
                    endOfDeckUI.style.display = '';
                    findShowButton.disabled = true;
                }

            }, 400); // Match dismiss animation duration
        }

        function handleSwipeStart(event) {
            const activeCard = cardElements[0];
            if (!activeCard || currentCardIndex < 0 || currentCardIndex >= shuffledShows.length || endOfDeckUI.style.display !== 'none') return;
            
            isSwiping = true;
            swipeStartX = event.touches ? event.touches[0].clientX : event.clientX;
            swipeStartY = event.touches ? event.touches[0].clientY : event.clientY;
            swipeStartTime = Date.now();
            swipeTranslateX = 0; 
            swipeTranslateY = 0;

            activeCard.style.transition = 'none'; 
            activeCard.classList.remove('card-top');
            activeCard.style.zIndex = '6'; // Ensure dragged card is on top (for 5 cards, max z-index is 5)
            activeCard.classList.remove('cursor-grab');
            activeCard.classList.add('cursor-grabbing');

            // Prepare the card behind for interactive scaling/opacity
            if (cardElements[1]) {
                cardElements[1].style.transition = 'none';
                // No need to remove .card-middle here, inline styles will override for now
            }

            if (event.type === 'mousedown') {
                document.addEventListener('mousemove', handleSwipeMove);
                document.addEventListener('mouseup', handleSwipeEnd);
            } else if (event.type === 'touchstart') {
                document.addEventListener('touchmove', handleSwipeMove, { passive: false });
                document.addEventListener('touchend', handleSwipeEnd);
            }
        }

        function handleSwipeMove(event) {
            if (!isSwiping) return;
            // event.preventDefault() is now only called if event.cancelable is true for touchmove
            if (event.type === 'touchmove' && event.cancelable) {
                event.preventDefault(); 
            }
            const activeCard = cardElements[0];
            if (!activeCard) return;

            const currentX = event.touches ? event.touches[0].clientX : event.clientX;
            const currentY = event.touches ? event.touches[0].clientY : event.clientY;
            swipeTranslateX = currentX - swipeStartX;
            swipeTranslateY = currentY - swipeStartY;

            const rotationAngle = swipeTranslateX / 20; 
            activeCard.style.transform = `translateX(${swipeTranslateX}px) translateY(${swipeTranslateY}px) rotate(${rotationAngle}deg)`;

            // Update the card behind (cardElements[1]) based on swipe progress
            if (cardElements[1]) {
                const dragDistance = Math.sqrt(swipeTranslateX * swipeTranslateX + swipeTranslateY * swipeTranslateY);
                const effectiveDismissThresholdForBubbling = SWIPE_DISMISS_THRESHOLD * 1.75;
                let progress = Math.min(1, dragDistance / effectiveDismissThresholdForBubbling);

                // Target styles for cardElements[1] when it becomes the top card
                const targetScale = 1.0;
                const targetTranslateY = 0;
                // const targetOpacity = 1.0; // Opacity change removed

                // Original styles for cardElements[1] (middle card)
                const originalScale = 0.95;
                const originalTranslateY = 15; // px
                // const originalOpacity = 0.8; // Opacity change removed

                const currentScale = originalScale + (targetScale - originalScale) * progress;
                const currentTranslateY = originalTranslateY + (targetTranslateY - originalTranslateY) * progress;
                // const currentOpacity = originalOpacity + (targetOpacity - originalOpacity) * progress; // Opacity change removed

                cardElements[1].style.transform = `scale(${currentScale}) translateY(${currentTranslateY}px)`;
                // cardElements[1].style.opacity = currentOpacity; // Opacity change removed
                // z-index remains managed by classes or direct set on dismiss
            }
        }

        function handleSwipeEnd(event) {
            if (!isSwiping) return;
            isSwiping = false;
            const activeCard = cardElements[0];
            if (!activeCard) return;
            
            activeCard.classList.remove('cursor-grabbing');
            // Add cursor-grab back if the card is still a valid, interactive card
            if (currentCardIndex >= 0 && currentCardIndex < shuffledShows.length && endOfDeckUI.style.display === 'none') {
                 activeCard.classList.add('cursor-grab');
            }

            if (event.type === 'mouseup') {
                document.removeEventListener('mousemove', handleSwipeMove);
                document.removeEventListener('mouseup', handleSwipeEnd);
            } else if (event.type === 'touchend') {
                document.removeEventListener('touchmove', handleSwipeMove);
                document.removeEventListener('touchend', handleSwipeEnd);
            }
            
            const swipeEndTime = Date.now();
            const swipeDuration = swipeEndTime - swipeStartTime;
            const swipeDistance = Math.sqrt(swipeTranslateX * swipeTranslateX + swipeTranslateY * swipeTranslateY);

            let overallVelocity = 0;
            if (swipeDuration > 10) { 
                overallVelocity = swipeDistance / swipeDuration;
            }

            activeCard.style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out';

            if (overallVelocity > MIN_SWIPE_VELOCITY && swipeDistance > SWIPE_DISMISS_THRESHOLD) {
                // Dismiss path
                // activeCard (cardToDismiss) retains its z-index: 6 from swipeStart or will be set in dismissAndCycleCards.
                // activeCard.style.zIndex = ''; // DO NOT clear zIndex here for dismissals
                dismissAndCycleCards(activeCard, swipeTranslateX, swipeTranslateY);
            } else { 
                // Snap back path
                // activeCard retains its style.zIndex = '4' (from handleSwipeStart) during this animation,
                // ensuring it stays on top of cardElements[1] while snapping back.
                activeCard.style.transform = 'translateX(0px) translateY(0px) rotate(0deg)';
                
                setTimeout(() => {
                    // This timeout runs after the snap-back animation (0.3s)
                    if (activeCard.style.opacity !== '0' && cardElements[0] === activeCard) { 
                        // Ensure the card is still the top card and hasn't been dismissed by another action
                        activeCard.classList.add('card-top'); // Re-apply .card-top (provides z-index: 3)
                        activeCard.style.zIndex = '';         // Now clear the inline style.zIndex='4', so .card-top's z-index applies.
                    }
                }, 300); // Match animation duration

                // Reset cardElements[1] back to its middle state with animation
                if (cardElements[1]) {
                    cardElements[1].style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out';
                    cardElements[1].classList.remove('card-top'); 
                    cardElements[1].classList.add('card-middle'); 
                    cardElements[1].style.transform = ''; 
                    cardElements[1].style.opacity = ''; 
                    cardElements[1].style.zIndex = ''; // Ensure class z-index for .card-middle applies
                }
            }
        }

        findShowButton.addEventListener('click', () => {
            if (!findShowButton.disabled) {
                 const activeCard = cardElements[0];
                 if(activeCard) {
                    const cardWidth = activeCard.offsetWidth;
                    dismissAndCycleCards(activeCard, -cardWidth * 0.3, 0); 
                 }
            }
        });
        reshuffleButton.addEventListener('click', startNewDeck);

        function setupSwipeListeners(element) {
            if (!element) return;
            // Remove any old listeners to prevent duplicates if called multiple times on the same element (though current logic shouldn't)
            element.removeEventListener('mousedown', handleSwipeStart);
            element.removeEventListener('touchstart', handleSwipeStart);

            element.addEventListener('mousedown', handleSwipeStart);
            element.addEventListener('touchstart', handleSwipeStart, { passive: false }); // passive: false needed for preventDefault in handleSwipeMove
        }

        document.addEventListener('DOMContentLoaded', () => {
            // Set initial placeholder for all cards - This can be simplified now that HTML has defaults
            // const initialImageSrc = "https://placehold.co/300x450/fce7f3/9d174d?text=Ready%3F";
            // cardElements.forEach(cardEl => {
            //     if (cardEl) {
            //         const imgFg = cardEl.querySelector('[data-role="image-fg"]');
            //         const imgBg = cardEl.querySelector('[data-role="image-bg"]');
            //         const titleEl = cardEl.querySelector('[data-role="title"]');
            //         const descriptionEl = cardEl.querySelector('[data-role="description"]');
            //         if(imgFg) imgFg.src = initialImageSrc;
            //         if(imgBg) imgBg.src = initialImageSrc;
            //         if(imgFg) imgFg.alt = "Show Poster";
            //         // Title and description can be set via HTML or cleared if preferred before startNewDeck
            //         // if(titleEl) titleEl.textContent = "Loading..."; 
            //         // if(descriptionEl) descriptionEl.textContent = "Please wait";
            //     }
            // });
            startNewDeck(); 
            setupSwipeListeners(cardElements[0]); // Initial setup for the first card
        });

        // Global error handler for images - now takes both fg and bg image elements
        function handleImageError(imageElementFg, imageElementBg) {
            const fallbackSrc = 'https://placehold.co/300x450/e9d5ff/581c87?text=Image+Not+Found';
            if (imageElementFg && imageElementFg.src !== fallbackSrc) {
                imageElementFg.src = fallbackSrc;
            }
            if (imageElementBg && imageElementBg.src !== fallbackSrc) { // Also set fallback for background
                imageElementBg.src = fallbackSrc;
            }
            if (imageElementFg) imageElementFg.onerror = null; 
        }
    </script>
</body>
</html>
